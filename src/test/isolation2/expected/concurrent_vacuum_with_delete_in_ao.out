-- This sql is to test vacuum concurrent with delete in partitioned append-only table
CREATE extension if not exists gp_inject_fault;
CREATE

CREATE TABLE sales_row (id int, date date, amt decimal(10,2)) WITH (appendonly=true) DISTRIBUTED BY (id) PARTITION BY RANGE (date) ( START (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
CREATE

INSERT INTO sales_row VALUES (generate_series(1,1000),'2008-01-01',10);
INSERT 1000

UPDATE sales_row SET amt = amt + 1;
UPDATE 1000

-- inject fault on ''vacuum_hold_lock''
SELECT gp_inject_fault('vacuum_hold_lock', 'suspend', dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1&: vacuum sales_row;  <waiting ...>

-- wait session1 until session1 arrive 'vacuum_hold_lock'
SELECT gp_wait_until_triggered_fault('vacuum_hold_lock', 1, dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

2&: DELETE FROM sales_row;  <waiting ...>

-- wait 2s because we want session2 arrive the acquire lock code
-- waitting for locks which hold by session1
SELECT pg_sleep(2);
 pg_sleep 
----------
          
(1 row)

-- release the lock holding by session1
SELECT gp_inject_fault('vacuum_hold_lock', 'reset', dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1<:  <... completed>
VACUUM
2<:  <... completed>
DELETE 1000

1q: ... <quitting>
2q: ... <quitting>

DROP TABLE sales_row;
DROP

-- second, we will test sql from cache plan.
CREATE TABLE sales_row (id int, date date, amt decimal(10,2)) WITH (appendonly=true) DISTRIBUTED BY (id) PARTITION BY RANGE (date) ( START (date '2008-01-01') INCLUSIVE END (date '2009-01-01') EXCLUSIVE EVERY (INTERVAL '1 month') );
CREATE

INSERT INTO sales_row VALUES (generate_series(1,1000),'2008-01-01',10);
INSERT 1000

-- prepare statement as test and execute multi times
-- when prepare statement execute multi times, the
-- statemnt will be cached.
2: PREPARE test AS DELETE FROM sales_row;
PREPARE

2: EXECUTE test;
EXECUTE 1000

2: EXECUTE test;
EXECUTE 0

2: EXECUTE test;
EXECUTE 0

2: EXECUTE test;
EXECUTE 0

2: EXECUTE test;
EXECUTE 0

-- inject fault on ''vacuum_hold_lock''
SELECT gp_inject_fault('vacuum_hold_lock', 'suspend', dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1&: vacuum sales_row;  <waiting ...>

-- wait session1 until session1 arrive 'vacuum_hold_lock'
SELECT gp_wait_until_triggered_fault('vacuum_hold_lock', 1, dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)

2&: EXECUTE test;  <waiting ...>

-- wait 2s because we want session2 arrive the acquire lock code
-- waitting for locks which hold by session1
SELECT pg_sleep(2);
 pg_sleep 
----------
          
(1 row)

-- release the lock holding by session1
SELECT gp_inject_fault('vacuum_hold_lock', 'reset', dbid) FROM gp_segment_configuration WHERE ROLE = 'p' AND content = -1;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

1<:  <... completed>
VACUUM
2<:  <... completed>
EXECUTE 0

1q: ... <quitting>
2q: ... <quitting>

DROP TABLE sales_row;
DROP
